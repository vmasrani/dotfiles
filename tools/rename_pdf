#!/usr/bin/env zsh
# rename_pdf - Rename PDF files using AI based on content
# Usage: rename_pdf [-f] <filename.pdf>
#   -f    Force rename even if file has already been processed

# Source gum utilities
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]:-$0}")" && pwd)"
source "$SCRIPT_DIR/../shell/gum_utils.sh"

# Parse flags
force=0
while getopts "f" opt; do
    case $opt in
        f) force=1 ;;
        *)
            gum_error "Error: Invalid option" "Usage: $0 [-f] <filename>"
            exit 1
            ;;
    esac
done
shift $((OPTIND - 1))

file="$1"

# Check if file argument provided
if [[ -z "$file" ]]; then
    gum_error "Error: No file provided" "Usage: $0 [-f] <filename>"
    exit 1
fi

# Check if file exists
if [[ ! -f "$file" ]]; then
    gum_error "Error: File not found" "'$file' does not exist"
    exit 1
fi

# Skip if already processed (has Green tag) unless force flag is set
if [[ $force -eq 0 ]] && tag -l "$file" 2>/dev/null | grep -q "Green"; then
    gum_dim "Skipping (already processed): $(basename "$file")"
    exit 0
fi

# Tag gray to indicate processing started
tag --add Gray "$file" 2>/dev/null

# Get file extension and original name
extension="${file##*.}"
old_basename="$(basename "$file")"
dir="$(dirname "$file")"

# Extract text from PDF
text=$(pdf_extract_pages "$file" | markitdown)

# Check if extraction succeeded
if [[ -z "$text" ]]; then
    tag --set Red "$file" 2>/dev/null
    gum_error "Error: Failed to extract text from PDF"
    exit 1
fi

# Generate new name using AI
system_prompt="$(cat $HOME/.claude/commands/file-renamer.md) $file."
# Save prompt to temp file to avoid shell escaping issues
temp_prompt="/tmp/rename_pdf_prompt_$$.txt"
echo "$system_prompt $text" > "$temp_prompt"
new_name=$(oai "$(cat "$temp_prompt")")
rm -f "$temp_prompt"

# Check if we got a valid response
if [[ -z "$new_name" ]]; then
    tag --set Red "$file" 2>/dev/null
    gum_error "Error: AI generation failed"
    exit 1
fi

# Sanitize filename (remove invalid characters for filesystems)
new_name="${new_name//[\/\\:*?\"<>|]/}"

# Build new filename, avoiding overwrites
base_new_name="$new_name"
new_filename="${dir}/${new_name}.${extension}"
counter=1

# If destination exists (and isn't the source), add numeric suffix
while [[ -e "$new_filename" && "$file" != "$new_filename" ]]; do
    new_name="${base_new_name} (${counter})"
    new_filename="${dir}/${new_name}.${extension}"
    ((counter++))
done

# Check if the name is actually changing
if [[ "$file" == "$new_filename" ]]; then
    tag --set Green "$file" 2>/dev/null
    gum_dim "File already has correct name: $old_basename"
    exit 0
fi

# Rename the file (no -f flag to be safe)
if ! mv -n -- "$file" "$new_filename" 2>/dev/null; then
    tag --set Red "$file" 2>/dev/null
    gum_error "Error: Failed to rename file (check permissions)"
    exit 1
fi

# Set green tag on renamed file
tag --set Green "$new_filename" 2>/dev/null

# Show result - multi-colored output on one line
gum_print_change "$old_basename" "${new_name}.${extension}"

