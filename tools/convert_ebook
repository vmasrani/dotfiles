#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.12"
# dependencies = [
#     "rich",
# ]
# ///

import sys
import time
import subprocess
from pathlib import Path
import json
import urllib.request
from urllib.parse import quote
import urllib.error
import urllib.request
from urllib.parse import quote, urlsplit, urlunsplit
import urllib.error
from rich.console import Console
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn

console = Console()
API_BASE = "https://api.convertio.co"


def read_api_key() -> str:
    api_key_path = Path.home() / ".convertio_api_key"
    return api_key_path.read_text().strip()


def http_json_post(url: str, payload: dict) -> dict:
    data = json.dumps(payload).encode("utf-8")
    req = urllib.request.Request(url, data=data, headers={"Content-Type": "application/json"}, method="POST")
    with urllib.request.urlopen(req) as resp:
        assert resp.status == 200
        return json.load(resp)


def http_json_put_file(url: str, file_path: Path) -> dict:
    blob = file_path.read_bytes()
    req = urllib.request.Request(url, data=blob, headers={"Content-Type": "application/octet-stream"}, method="PUT")
    with urllib.request.urlopen(req) as resp:
        assert resp.status == 200
        return json.load(resp)


def http_json_get(url: str) -> dict:
    with urllib.request.urlopen(url) as resp:
        assert resp.status == 200
        return json.load(resp)


def start_conversion(api_key: str, filename: str, input_format: str, output_format: str) -> str:
    url = f"{API_BASE}/convert"
    payload = {
        "apikey": api_key,
        "input": "upload",
        "filename": filename,
        "inputformat": input_format,
        "outputformat": output_format,
    }
    data = http_json_post(url, payload)
    assert data.get("status") == "ok"
    return data["data"]["id"]


def upload_file(conversion_id: str, filename: str, file_path: Path) -> None:
    encoded = quote(filename, safe="")
    url = f"{API_BASE}/convert/{conversion_id}/{encoded}"
    data = http_json_put_file(url, file_path)
    assert data.get("status") == "ok"


def get_status(conversion_id: str) -> dict:
    url = f"{API_BASE}/convert/{conversion_id}/status"
    return http_json_get(url)


def wait_for_finish(conversion_id: str, poll_seconds: float = 1.0) -> dict:
    while True:
        status_payload = get_status(conversion_id)
        if status_payload.get("status") != "ok":
            raise RuntimeError(status_payload.get("error", "Unknown error from Convertio"))
        step = status_payload["data"].get("step")
        if step == "finish":
            return status_payload["data"]
        time.sleep(poll_seconds)


def download_output_file(output_url: str, dest_path: Path) -> None:
    parts = urlsplit(output_url)
    safe_url = urlunsplit((
        parts.scheme,
        parts.netloc,
        quote(parts.path, safe="/%"),
        quote(parts.query, safe="=&%"),
        quote(parts.fragment, safe="")
    ))
    with urllib.request.urlopen(safe_url) as r:
        with dest_path.open("wb") as f:
            _ = [f.write(chunk) for chunk in iter(lambda: r.read(1024 * 1024), b"") if chunk]

def convert_to_pdf(api_key: str, source: Path) -> Path:
    output_file = source.with_suffix(".pdf")
    input_format = source.suffix.lstrip(".").lower()

    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        console=console,
    ) as progress:
        task = progress.add_task("Converting to PDF...", total=None)
        conversion_id = start_conversion(api_key, source.name, input_format, "pdf")
        upload_file(conversion_id, source.name, source)
        result = wait_for_finish(conversion_id)
        output_url = result["output"]["url"]
        download_output_file(output_url, output_file)
        progress.update(task, completed=True)

    console.print("[green]Conversion to PDF successful.[/green]")
    return output_file


def tag_file(filepath: Path, add_tags: list[str] = None, remove_tags: list[str] = None) -> None:
    """Tag a file using macOS tag command."""
    cmd = ["tag"]
    if remove_tags:
        for t in remove_tags:
            cmd.extend(["--remove", t])
    if add_tags:
        for t in add_tags:
            cmd.extend(["--add", t])
    cmd.append(str(filepath))
    subprocess.run(cmd, stderr=subprocess.DEVNULL, check=False)


def main() -> None:
    if len(sys.argv) != 2:
        console.print(Panel(
            f"[red]Error: No file provided[/red]\n[dim]Usage: {Path(sys.argv[0]).name} <input_file>[/dim]",
            border_style="red",
            padding=(0, 1)
        ))
        sys.exit(1)

    input_path = Path(sys.argv[1]).expanduser().resolve()
    if not input_path.exists():
        console.print(Panel(
            f"[red]Error: File not found[/red]\n[dim]'{input_path}' does not exist[/dim]",
            border_style="red",
            padding=(0, 1)
        ))
        sys.exit(1)

    # Tag gray to indicate processing started
    tag_file(input_path, add_tags=["Gray"])

    suffix = input_path.suffix.lower()
    if suffix == ".pdf":
        tag_file(input_path, add_tags=["Green"], remove_tags=["Gray"])
        console.print("[dim]Already a PDF. Nothing to do.[/dim]")
        return

    if suffix not in {".epub", ".mobi"}:
        tag_file(input_path, add_tags=["Red"], remove_tags=["Gray"])
        console.print(Panel(
            f"[red]Error: Unsupported input format '{suffix}'[/red]\n[dim]Only .epub, .mobi, or .pdf are supported[/dim]",
            border_style="red",
            padding=(0, 1)
        ))
        sys.exit(1)

    api_key = read_api_key()
    try:
        pdf_file = convert_to_pdf(api_key, input_path)
    except urllib.error.HTTPError as e:
        tag_file(input_path, add_tags=["Red"], remove_tags=["Gray"])
        if e.code == 422:
            console.print(Panel(
                "[red]Error: Conversion limit reached[/red]\n[dim]You've reached your conversion limit for the last 24 hours (HTTP 422)[/dim]",
                border_style="red",
                padding=(0, 1)
            ))
            sys.exit(1)
        else:
            raise
    if not pdf_file.exists():
        tag_file(input_path, add_tags=["Red"], remove_tags=["Gray"])
        console.print(Panel(
            f"[red]Error: PDF creation failed[/red]\n[dim]The PDF file '{pdf_file}' was not created[/dim]",
            border_style="red",
            padding=(0, 1)
        ))
        sys.exit(1)

    # Tag the new PDF file green and remove tags from original
    tag_file(pdf_file, add_tags=["Green"])
    tag_file(input_path, remove_tags=["Gray"])

    old_name = input_path.name
    new_name = pdf_file.name
    console.print(f"[dim]{old_name}[/dim] [bright_black]â†’[/bright_black] [cyan]{new_name}[/cyan]")


if __name__ == "__main__":
    main()
